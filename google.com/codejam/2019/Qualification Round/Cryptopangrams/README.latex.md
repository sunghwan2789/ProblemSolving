# Cryptopangrams

- [x] 10pts
- [ ] 15pts

## 문제

모든 영어 알파벳을 한 번 이상 사용한 문장을 $S$라 하자.
$N$ 보다 작거나 같은 소수 26개를 오름차순으로 선택하고 $P$라 하자.
이를 숫자가 작은 순서대로 `A`부터 `Z`까지의 문자로 매핑한다.

암호 메시지 $C$는 다음 규칙을 따라 구한다.

1. $S$에서 모든 공백을 제거한다.
2. $C_i = P[S_i] \times P[S_{i + 1}] ~~ (단, 0 \leq i \lt |S| - 1)$

$C$와 $N$을 받아 $S$를 구하는 프로그램을 작성하시오.

## 풀이

$C_i$에서 소수 두 개, 즉, $P[S_i]$와 $P[S_{i + 1}]$를 추출한다.
이 원소들을 중복 없이 오름차순으로 정렬하고, `A`부터 `Z`까지의 문자로 매핑한다.
추출한 순서대로 소수를 문자로 역매핑하면 문제 해결!

### 소수 구하기

[에라토스테네스의 체](https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4)로 구현하였다.
소수를 어떻게 구하냐가 이 문제의 핵심인 것 같다...

### 소수 추출하기

$C_i = P[S_i] \times P[S_{i + 1}]$이면 $C_{i + 1} = P[S_{i + 1}] \times P[S_{i + 2}]$이다.
$P[S_{i + 1}]$을 가정하는 임의의 소수 $x$를 선택하자.
$C_i \bmod x = 0$이고 $C_{i + 1} \bmod x = 0$이면 $x = P[S_{i + 1}]$이다.

이 $x$를 하나만 구하면, 나머지는 $P[S_{i + 2}] = C_{i + 1} \div P[S_{i + 1}]$이므로 선형 시간에 구할 수 있다.

여기서 $C_i = C_{i + 1}$이면 $x$를 특정할 수 없음에 주의한다.

### 중복 없이 오름차순 정렬하기

C++에는 `std::set<T>`가 있다. 이는 원소를 중복 없이 오름차순 정렬하여 관리하는 컨테이너이므로, 갖다 쓰면 되겠다!!

### 소수를 문자로 역매핑하기

`set`에 소수를 추가한 다음, 추출한 소수 리스트를 순회한다.
이제 `set`에서 각 소수의 순번을 찾고, 해당하는 문자를 `A`부터 매핑한다.
해당하는 코드는 `'A' + std::distance(set.begin(), set.find(i))`가 되겠다.
